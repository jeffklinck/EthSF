use unique::@init_once;

storage {
    bid_amount: int,
    
    price: int, // A for B price (Eth/USDC = 3000),

    owner: b256,
    nonce: int,
}

predicate Bid{
    var amount: int;

    interface TokenAInstance = Token(unique::contract_A);
    interface TokenBInstance = Token(unique::contract_B);

    state amount_left = mut storage::bid_amount;

    state owner = mut storage::owner;
    
    state balance_A = TokenAInstance::storage::balances[owner];
    state balance_B = TokenBInstance::storage::balances[owner];
    state nonce = mut storage::nonce;

    state price = mut storage::price;

    constraint amount > 0;

    constraint amount_left' == amount_left - amount;

    constraint balance_A' == balance_A + amount;
    constraint balance_B' == balance_B - amount * price;

    constraint amount_left' == amount_left - amount;
    constraint balance_B' >= 0;

    constraint owner' == owner;

    constraint @init_once(nonce; unique::nonce);
}

predicate Ask{
    var amount: int;

    interface TokenAInstance = Token(unique::contract_A);
    interface TokenBInstance = Token(unique::contract_B);

    state amount_left = mut storage::bid_amount;

    state owner = mut storage::owner;
    
    state balance_A = TokenAInstance::storage::balances[owner];
    state balance_B = TokenBInstance::storage::balances[owner];
    state nonce = mut storage::nonce;

    state price = mut storage::price;

    constraint amount > 0;

    constraint amount_left' == amount_left - amount;

    constraint balance_A' == balance_A - amount;
    constraint balance_B' == balance_B + amount * price;

    constraint amount_left' == amount_left - amount;
    constraint balance_B' >= 0;

    constraint owner' == owner;

    constraint @init_once(nonce; unique::nonce);
}

predicate UpdateVars {
    var new_amount: int;
    var new_price: int;

    state n_amount = mut storage::bid_amount;
    state n_price = mut storage::price;
    state nonce = mut storage::nonce;

    constraint n_amount' == new_amount;
    constraint n_price' == new_price;

    constraint @init_once(nonce; unique::nonce);
}

interface Token {
    storage {
        total_supply: int,
        balances: (b256 => int),
    }

    predicate Mint {
        pub var receiver: b256;
        pub var amount: int;
    }

    predicate Send {
        pub var from: b256;
        pub var receiver: b256;
        pub var amount: int;
    }
}