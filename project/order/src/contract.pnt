storage {
    bid_amount: int,
    
    price: int, // A for B price (Eth/USDC = 3000),

    contract_A: b256,
    contract_B: b256,

    owner: b256,
}

predicate Order{
    var amount: int;

    interface TokenAInstance = Token(storage::contract_A);
    interface TokenBInstance = Token(storage::contract_B);

    state amount_left: int = mut storage::bid_amount;
    state balance_A = TokenAInstance::storage::balances[owner];
    state balance_B = TokenBInstance::storage::balances[owner];
    state owner = mut storage::owner;

    constraint amount > 0;

    constraint amount_left' == amount_left - amount;

    contraint balance_A' == balance_A + amount;
    constraint balance_B' == balance_B - amount * price;

    constraint amount_left' == amount_left - amount;
    constaint balance_B' >= 0;

    constraint owner' == owner;
}

predicate UpdateVars {
    var new_amount: int;
    var new_price: int;
    var new_A_id: b256;
    var new_B_id: b256;

    state n_amount = mut storage::bid_amount;
    state n_price = mut storage::price;
    state n_a_addr = mut storage::contract_A;
    state n_b_addr = mut storage::contract_B;

    n_amount' == new_amount;
    n_price' == new_price;
    new_a_addr' == new_A_id;
    new_b_addr' == new_B_id;
}